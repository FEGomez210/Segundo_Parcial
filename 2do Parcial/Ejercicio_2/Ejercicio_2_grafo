from heap import HeapMin
from queue_ import Queue
from stack import Stack


class Graph:
    def __init__(self, dirigido=True):
        self.elements = []
        self.dirigido = dirigido

    def show_graph(self):
        print()
        print("NODOS DEL GRAFO")
        for nodo in self.elements:
            print(f"Vértice: {nodo['value']}")
            print("    Aristas:")
            for arista in nodo['aristas']:
                print(f"    destino: {arista['value']}  peso: {arista['peso']}")
        print()

    def search(self, value):
        """Busca un vértice por su valor, y devuelve la posición en self.elements."""
        for index, element in enumerate(self.elements):
            if element['value'] == value:
                return index
        return None

    def search_arista(self, vertice_value, value):
        """Busca una arista (destino) dentro de la lista de aristas de un vértice."""
        pos_origen = self.search(vertice_value)
        if pos_origen is not None:
            for index, element in enumerate(self.elements[pos_origen]['aristas']):
                if element['value'] == value:
                    return pos_origen, index
        return None

    def insert_vertice(self, value, episodios=None):
        """Inserta un vértice. 'episodios' puede ser una lista con los episodios donde aparece."""
        nodo = {
            'value': value,
            'aristas': [],
            'visitado': False,
            'episodios': episodios if episodios is not None else []
        }
        self.elements.append(nodo)

    def insert_arista(self, origen, destino, peso):
        """Inserta una arista entre origen y destino, con peso = cantidad de episodios en común."""
        pos_origen = self.search(origen)
        pos_destino = self.search(destino)
        if pos_origen is not None and pos_destino is not None:
            arista = {
                'value': destino,
                'peso': peso
            }
            self.elements[pos_origen]['aristas'].append(arista)
            if not self.dirigido:
                arista = {
                    'value': origen,
                    'peso': peso
                }
                self.elements[pos_destino]['aristas'].append(arista)

    def delete_arista(self, origen, destino):
        result = self.search_arista(origen, destino)
        if result:
            pos_vertice, pos_arista = result
            value = self.elements[pos_vertice]['aristas'].pop(pos_arista)
            if not self.dirigido:
                result = self.search_arista(destino, origen)
                if result:
                    pos_vertice, pos_arista = result
                    self.elements[pos_vertice]['aristas'].pop(pos_arista)
            return value

    def delete_vertice(self, value):
        pos_vertice = self.search(value)
        if pos_vertice is not None:
            delete_value = self.elements.pop(pos_vertice)
            for nodo in self.elements:
                self.delete_arista(nodo['value'], value)
            return delete_value

    def mark_as_not_visited(self):
        for nodo in self.elements:
            nodo['visitado'] = False

    def deep_show(self, origin):
        def __deep_show(graph, origin):
            pos_vertice = graph.search(origin)
            if pos_vertice is not None:
                if not graph.elements[pos_vertice]['visitado']:
                    graph.elements[pos_vertice]['visitado'] = True
                    print(graph.elements[pos_vertice]['value'])
                    adyacentes = graph.elements[pos_vertice]['aristas']
                    for adyacente in adyacentes:
                        __deep_show(graph, adyacente['value'])

        self.mark_as_not_visited()
        __deep_show(self, origin)

    def amplitude_show(self, origin):
        self.mark_as_not_visited()
        cola = Queue()
        pos_vertice = self.search(origin)
        if pos_vertice is not None:
            self.elements[pos_vertice]['visitado'] = True
            cola.arrive(self.elements[pos_vertice])
            while cola.size() > 0:
                nodo = cola.attention()
                print(nodo['value'])
                adyacentes = nodo['aristas']
                for adyacente in adyacentes:
                    pos_adyacente = self.search(adyacente['value'])
                    if not self.elements[pos_adyacente]['visitado']:
                        self.elements[pos_adyacente]['visitado'] = True
                        cola.arrive(self.elements[pos_adyacente])

    def exist_path(self, origen, destino):
        def __exist_path(graph, origin, destino):
            result = False
            pos_vertice = graph.search(origin)
            if pos_vertice is not None:
                if not graph.elements[pos_vertice]['visitado']:
                    graph.elements[pos_vertice]['visitado'] = True
                    if graph.elements[pos_vertice]['value'] == destino:
                        return True
                    else:
                        adyacentes = graph.elements[pos_vertice]['aristas']
                        for adyacente in adyacentes:
                            result = __exist_path(graph, adyacente['value'], destino)
                            if result:
                                break
            return result

        self.mark_as_not_visited()
        result = __exist_path(self, origen, destino)
        return result

    def dijkstra(self, origen):
        from math import inf
        no_visitados = HeapMin()
        camino = Stack()
        for nodo in self.elements:
            distancia = 0 if nodo['value'] == origen else inf
            no_visitados.arrive([nodo['value'], nodo, None], distancia)

        while no_visitados.size() > 0:
            elemento = no_visitados.attention()
            dist_actual = elemento[0]
            nombre, nodo_dict, padre = elemento[1]
            camino.push([nombre, dist_actual, padre])

            for adyacente in nodo_dict['aristas']:
                pos = no_visitados.search(adyacente['value'])
                if pos is not None:
                    nueva_dist = dist_actual + adyacente['peso']
                    if nueva_dist < no_visitados.elements[pos][0]:
                        no_visitados.elements[pos][1][2] = nombre
                        no_visitados.change_priority(pos, nueva_dist)

        return camino

    def kruskal(self, origen):
        def buscar_en_bosque(bosque, buscado):
            for index, arbol in enumerate(bosque):
                if buscado in arbol:
                    return index
            return None

        bosque = []
        aristas = HeapMin()

        for nodo in self.elements:
            bosque.append(nodo['value'])
            adjacentes = nodo['aristas']
            for adjacente in adjacentes:
                aristas.arrive([nodo['value'], adjacente['value']], adjacente['peso'])

        while len(bosque) > 1 and aristas.size() > 0:
            arista = aristas.attention()
            peso = arista[0]
            origen_arista = arista[1][0]
            destino_arista = arista[1][1]

            ori = buscar_en_bosque(bosque, origen_arista)
            des = buscar_en_bosque(bosque, destino_arista)

            if ori is not None and des is not None and ori != des:
                if ori > des:
                    vertice_ori = bosque.pop(ori)
                    vertice_des = bosque.pop(des)
                else:
                    vertice_des = bosque.pop(des)
                    vertice_ori = bosque.pop(ori)

                if '-' not in vertice_ori and '-' not in vertice_des:
                    bosque.append(f'{vertice_ori}-{vertice_des}-{peso}')
                elif '-' not in vertice_des:
                    bosque.append(vertice_ori + ';' + f'{origen_arista}-{vertice_des}-{peso}')
                elif '-' not in vertice_ori:
                    bosque.append(vertice_des + ';' + f'{vertice_ori}-{destino_arista}-{peso}')
                else:
                    bosque.append(vertice_ori + ';' + vertice_des + ';' + f'{origen_arista}-{destino_arista}-{peso}')
        idx = buscar_en_bosque(bosque, origen)
        if idx is not None:
            return bosque[idx]
        return bosque


# ============================================================
#   CARGA DEL GRAFO DE STAR WARS
# ============================================================

def cargar_grafo_star_wars():
    personajes = [
        "Luke Skywalker", "Darth Vader", "Yoda", "Boba Fett",
        "C-3PO", "Leia", "Rey", "Kylo Ren",
        "Chewbacca", "Han Solo", "R2-D2", "BB-8"
    ]

    aristas = [
        ("Luke Skywalker", "Darth Vader", 5),
        ("Luke Skywalker", "Yoda", 4),
        ("Luke Skywalker", "Leia", 6),
        ("Luke Skywalker", "Han Solo", 6),
        ("Darth Vader", "Leia", 5),
        ("Darth Vader", "Kylo Ren", 3),
        ("Yoda", "Leia", 2),
        ("Yoda", "Darth Vader", 2),
        ("Boba Fett", "Darth Vader", 2),
        ("C-3PO", "R2-D2", 7),
        ("Leia", "Rey", 3),
        ("Rey", "Kylo Ren", 4),
        ("Chewbacca", "Han Solo", 6),
        ("Han Solo", "BB-8", 2),
        ("BB-8", "Rey", 3),
        ("Chewbacca", "C-3PO", 2),
        ("R2-D2", "Yoda", 2),
        ("C-3PO", "Leia", 5),
        ("Yoda", "Chewbacca", 2),
        ("Kylo Ren", "Darth Vader", 4),
    ]

    episodios_por_personaje = {
        "C-3PO": list(range(1, 10)),   
        "R2-D2": list(range(1, 10)),   
    }

    grafo = Graph(dirigido=False)

    # Insertamos vértices
    for personaje in personajes:
        grafo.insert_vertice(personaje, episodios=episodios_por_personaje.get(personaje, []))

    for origen, destino, peso in aristas:
        grafo.insert_arista(origen, destino, peso)

    return grafo


# ============================================================
#   PUNTO: ÁRBOLES DE EXPANSIÓN MÍNIMA PARA C-3PO, Yoda y Leia
# ============================================================

def arbol_expansion_minimo_personaje(grafo, personaje):
    mst_str = grafo.kruskal(personaje)
    aristas_mst = []
    peso_total = 0
    for arista_txt in mst_str.split(';'):
        partes = arista_txt.split('-')
        if len(partes) == 3:
            origen, destino, peso = partes
            peso = int(peso)
            aristas_mst.append((origen, destino, peso))
            peso_total += peso

    return aristas_mst, peso_total


# ============================================================
#   PUNTO: máximo número de episodios compartidos y los pares
# ============================================================

def maximo_episodios_y_pares(grafo):
    max_peso = -1
    pares = []
    vistos = set()

    for nodo in grafo.elements:
        origen = nodo['value']
        for arista in nodo['aristas']:
            destino = arista['value']
            peso = arista['peso']
            par = tuple(sorted([origen, destino]))
            if par in vistos:
                continue
            vistos.add(par)

            if peso > max_peso:
                max_peso = peso
                pares = [par]
            elif peso == max_peso:
                pares.append(par)

    return max_peso, pares


# ============================================================
#   PUNTO: camino más corto entre pares de personajes
# ============================================================

def camino_mas_corto(grafo, origen, destino):
    pila_camino = grafo.dijkstra(origen)
    actual = destino
    peso_total = None
    camino = []
    while pila_camino.size() > 0:
        nombre, costo, padre = pila_camino.pop()
        if nombre == actual:
            if peso_total is None:
                peso_total = costo
            camino.append(nombre)
            actual = padre

    camino.reverse()
    return camino, peso_total


# ============================================================
#   PUNTO: personajes que aparecen en los 9 episodios
# ============================================================

def personajes_en_nueve_episodios(grafo, total_episodios=9):
    resultado = []
    for nodo in grafo.elements:
        episodios = nodo.get('episodios', [])
        if len(episodios) == total_episodios:
            resultado.append(nodo['value'])
    return resultado


# ============================================================
#   PROGRAMA PRINCIPAL (demostración de todos los puntos)
# ============================================================

if __name__ == "__main__":
    grafo = cargar_grafo_star_wars()

    # 1) Mostrar grafo (opcional, para verificar)
    grafo.show_graph()

    # 2) Árbol de expansión mínimo desde C-3PO, Yoda y Leia
    for personaje in ["C-3PO", "Yoda", "Leia"]:
        mst, peso = arbol_expansion_minimo_personaje(grafo, personaje)
        print(f"\nÁrbol de expansión mínimo desde {personaje}:")
        for o, d, w in mst:
            print(f"  {o} - {d}  (peso: {w})")
        print("  Peso total:", peso)

    # 3) Máximo número de episodios compartidos y pares
    max_peso, pares = maximo_episodios_y_pares(grafo)
    print(f"\nMáximo número de episodios compartidos: {max_peso}")
    print("Pares de personajes que comparten ese número:")
    for p1, p2 in pares:
        print(f"  {p1} - {p2}")

    # 4) Caminos más cortos
    camino_c3po_r2, costo_c3po_r2 = camino_mas_corto(grafo, "C-3PO", "R2-D2")
    print(f"\nCamino más corto de C-3PO a R2-D2: {' -> '.join(camino_c3po_r2)}  (costo: {costo_c3po_r2})")

    camino_yoda_vader, costo_yoda_vader = camino_mas_corto(grafo, "Yoda", "Darth Vader")
    print(f"Camino más corto de Yoda a Darth Vader: {' -> '.join(camino_yoda_vader)}  (costo: {costo_yoda_vader})")

    # 5) Personajes que aparecen en los 9 episodios
    en_nueve = personajes_en_nueve_episodios(grafo)
    print("\nPersonajes que aparecen en los nueve episodios de la saga:")
    for pers in en_nueve:
        print("  ", pers)
